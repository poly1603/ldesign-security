import { execa } from 'execa'
import type { Vulnerability } from '../types'

/**
 * 漏洞检查器 - 检查依赖漏洞
 */
export class VulnerabilityChecker {
  constructor(private projectDir: string = process.cwd()) {}
  
  /**
   * 检查漏洞
   */
  async check(): Promise<Vulnerability[]> {
    try {
      // 使用 npm audit
      const result = await this.runNpmAudit()
      return result
    } catch (error) {
      console.warn('漏洞检查失败:', error)
      return []
    }
  }
  
  /**
   * 运行 npm audit
   */
  private async runNpmAudit(): Promise<Vulnerability[]> {
    try {
      const { stdout } = await execa('npm', ['audit', '--json'], {
        cwd: this.projectDir,
        reject: false
      })
      
      const auditResult = JSON.parse(stdout)
      const vulnerabilities: Vulnerability[] = []
      
      if (auditResult.vulnerabilities) {
        for (const [name, data] of Object.entries(auditResult.vulnerabilities as Record<string, any>)) {
          if (data.severity) {
            vulnerabilities.push({
              package: name,
              severity: data.severity,
              title: data.via?.[0]?.title || 'Unknown vulnerability',
              description: data.via?.[0]?.description || '',
              recommendation: data.fixAvailable ? 'Update available' : 'No fix available',
              url: data.via?.[0]?.url || ''
            })
          }
        }
      }
      
      return vulnerabilities
    } catch (error) {
      return []
    }
  }
  
  /**
   * 修复漏洞
   */
  async fix(): Promise<{ success: boolean; message: string }> {
    try {
      await execa('npm', ['audit', 'fix'], {
        cwd: this.projectDir
      })
      
      return {
        success: true,
        message: '漏洞修复完成'
      }
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : '修复失败'
      }
    }
  }
}

