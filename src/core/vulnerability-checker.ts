import { execa } from 'execa'
import fs from 'fs-extra'
import path from 'path'
import type { Vulnerability } from '../types'
import { logger } from '../utils/logger'
import { ScanError } from '../errors/SecurityError'

/**
 * 漏洞检查器 - 多源漏洞检测（NPM Audit + OSV）
 * 
 * @description
 * 该类负责从多个安全漏洞数据源检测项目依赖中的已知安全漏洞。
 * 支持的数据源包括：
 * - NPM Audit：npm 官方漏洞数据库
 * - OSV (Open Source Vulnerabilities)：跨生态系统的漏洞数据库
 * 
 * @example
 * ```typescript
 * const checker = new VulnerabilityChecker('./my-project')
 * const vulnerabilities = await checker.check()
 * console.log(`Found ${vulnerabilities.length} vulnerabilities`)
 * 
 * // 修复漏洞
 * const result = await checker.fix()
 * console.log(`Fixed ${result.fixed} vulnerabilities`)
 * ```
 */
export class VulnerabilityChecker {
  private logger = logger.child('VulnerabilityChecker')

  /**
   * 创建漏洞检查器实例
   * 
   * @param {string} projectDir - 项目根目录路径，默认为当前工作目录
   */
  constructor(private projectDir: string = process.cwd()) { }

  /**
   * 检查项目依赖中的安全漏洞
   * 
   * @description
   * 该方法会并行执行多个漏洞源的检查：
   * - NPM Audit：检查 npm 注册表中已知的漏洞
   * - OSV：查询 Open Source Vulnerabilities 数据库
   * 
   * 检查完成后会自动去重，相同 CVE 或相同包名+标题的漏洞只保留一个。
   * 
   * @returns {Promise<Vulnerability[]>} 去重后的漏洞列表
   * @throws {ScanError} 当扫描过程发生不可恢复的错误时
   * 
   * @example
   * ```typescript
   * const checker = new VulnerabilityChecker('./my-project')
   * const vulnerabilities = await checker.check()
   * 
   * vulnerabilities.forEach(vuln => {
   *   console.log(`${vuln.package}: ${vuln.severity} - ${vuln.title}`)
   *   if (vuln.fixAvailable) {
   *     console.log(`Fix: ${vuln.recommendation}`)
   *   }
   * })
   * ```
   */
  async check(): Promise<Vulnerability[]> {
    try {
      // 并行运行多个检测源
      const [npmVulns, osvVulns] = await Promise.all([
        this.runNpmAudit(),
        this.runOSVCheck()
      ])

      // 合并并去重
      const allVulns = [...npmVulns, ...osvVulns]
      return this.deduplicateVulnerabilities(allVulns)
    } catch (error) {
      this.logger.error('漏洞检查失败', error as Error)
      // 对于漏洞检查失败，返回空数组而不是抛出异常
      // 这样不会阻止其他安全检查的执行
      return []
    }
  }

  /**
   * 运行 NPM Audit 漏洞检查
   * 
   * @description
   * 使用 npm audit 命令检查项目依赖中的已知漏洞。
   * 该命令会检查 package.json 中声明的所有依赖及其传递依赖。
   * 
   * @returns {Promise<Vulnerability[]>} NPM Audit 检测到的漏洞列表
   * @private
   */
  private async runNpmAudit(): Promise<Vulnerability[]> {
    try {
      const { stdout } = await execa('npm', ['audit', '--json'], {
        cwd: this.projectDir,
        reject: false
      })

      const auditResult = JSON.parse(stdout)
      const vulnerabilities: Vulnerability[] = []

      if (auditResult.vulnerabilities) {
        for (const [name, data] of Object.entries(auditResult.vulnerabilities as Record<string, any>)) {
          if (data.severity) {
            const via = Array.isArray(data.via) ? data.via[0] : data.via

            vulnerabilities.push({
              package: name,
              severity: this.normalizeSeverity(data.severity),
              title: via?.title || 'Unknown vulnerability',
              description: via?.description || '',
              recommendation: data.fixAvailable
                ? `Update to ${typeof data.fixAvailable === 'object' ? data.fixAvailable.version : 'latest version'}`
                : 'No fix available yet',
              url: via?.url || `https://www.npmjs.com/package/${name}`,
              cve: via?.cve || undefined,
              cvss: via?.cvss?.score || undefined,
              source: 'npm',
              fixAvailable: !!data.fixAvailable,
              fixVersion: typeof data.fixAvailable === 'object' ? data.fixAvailable.version : undefined
            })
          }
        }
      }

      return vulnerabilities
    } catch (error) {
      return []
    }
  }

  /**
   * 运行 OSV (Open Source Vulnerabilities) 漏洞检查
   * 
   * @description
   * 查询 OSV 数据库以检测项目依赖中的已知漏洞。
   * OSV 是一个跨生态系统的开源漏洞数据库，包含来自多个来源的漏洞信息。
   * 
   * @returns {Promise<Vulnerability[]>} OSV 数据库中检测到的漏洞列表
   * @private
   */
  private async runOSVCheck(): Promise<Vulnerability[]> {
    try {
      const packageJsonPath = path.join(this.projectDir, 'package.json')
      const packageJson = await fs.readJSON(packageJsonPath)

      const vulnerabilities: Vulnerability[] = []
      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      }

      // OSV API 批量查询
      for (const [pkgName, version] of Object.entries(allDeps)) {
        try {
          const osvVulns = await this.queryOSV(pkgName, version as string)
          vulnerabilities.push(...osvVulns)
        } catch {
          // 忽略单个包的查询失败
        }
      }

      return vulnerabilities
    } catch (error) {
      return []
    }
  }

  /**
   * 查询 OSV 数据库
   */
  private async queryOSV(packageName: string, version: string): Promise<Vulnerability[]> {
    try {
      // 使用 fetch 调用 OSV API
      const response = await fetch('https://api.osv.dev/v1/query', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          package: {
            name: packageName,
            ecosystem: 'npm'
          },
          version: version.replace(/^[\^~]/, '')
        })
      })

      if (!response.ok) {
        return []
      }

      const data = await response.json()
      const vulnerabilities: Vulnerability[] = []

      if (data.vulns && Array.isArray(data.vulns)) {
        for (const vuln of data.vulns) {
          vulnerabilities.push({
            package: packageName,
            severity: this.calculateSeverityFromOSV(vuln),
            title: vuln.summary || vuln.id,
            description: vuln.details || vuln.summary || '',
            recommendation: this.getOSVRecommendation(vuln),
            url: vuln.database_specific?.url || `https://osv.dev/vulnerability/${vuln.id}`,
            cve: vuln.aliases?.find((a: string) => a.startsWith('CVE-')),
            cvss: this.extractCVSS(vuln),
            source: 'osv',
            fixAvailable: !!vuln.affected?.[0]?.ranges?.[0]?.events?.some((e: any) => e.fixed)
          })
        }
      }

      return vulnerabilities
    } catch (error) {
      return []
    }
  }

  /**
   * 从 OSV 数据计算严重程度
   */
  private calculateSeverityFromOSV(vuln: any): 'critical' | 'high' | 'medium' | 'low' {
    // 尝试从 CVSS 分数计算
    const cvssScore = this.extractCVSS(vuln)

    if (cvssScore) {
      if (cvssScore >= 9.0) return 'critical'
      if (cvssScore >= 7.0) return 'high'
      if (cvssScore >= 4.0) return 'medium'
      return 'low'
    }

    // 尝试从数据库特定字段获取
    const severity = vuln.database_specific?.severity?.toLowerCase()
    if (severity === 'critical') return 'critical'
    if (severity === 'high') return 'high'
    if (severity === 'moderate' || severity === 'medium') return 'medium'
    if (severity === 'low') return 'low'

    return 'medium' // 默认
  }

  /**
   * 提取 CVSS 分数
   */
  private extractCVSS(vuln: any): number | undefined {
    if (vuln.severity?.[0]?.score) {
      const score = parseFloat(vuln.severity[0].score)
      if (!isNaN(score)) return score
    }

    if (vuln.database_specific?.cvss_score) {
      const score = parseFloat(vuln.database_specific.cvss_score)
      if (!isNaN(score)) return score
    }

    return undefined
  }

  /**
   * 获取 OSV 修复建议
   */
  private getOSVRecommendation(vuln: any): string {
    const fixed = vuln.affected?.[0]?.ranges?.[0]?.events?.find((e: any) => e.fixed)
    if (fixed) {
      return `Update to version ${fixed.fixed} or later`
    }

    if (vuln.affected?.[0]?.versions) {
      return 'Affected versions found, please update to a safe version'
    }

    return 'Review the vulnerability details and update if possible'
  }

  /**
   * 去重漏洞（基于包名和 CVE）
   */
  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Map<string, Vulnerability>()

    for (const vuln of vulnerabilities) {
      const key = vuln.cve
        ? `${vuln.package}:${vuln.cve}`
        : `${vuln.package}:${vuln.title}`

      const existing = seen.get(key)

      if (!existing) {
        seen.set(key, vuln)
      } else {
        // 保留更严重的或信息更完整的
        if (this.severityScore(vuln.severity) > this.severityScore(existing.severity)) {
          seen.set(key, vuln)
        } else if (vuln.cvss && !existing.cvss) {
          seen.set(key, vuln)
        }
      }
    }

    return Array.from(seen.values())
  }

  /**
   * 严重程度评分（用于比较）
   */
  private severityScore(severity: string): number {
    const scores: Record<string, number> = {
      critical: 4,
      high: 3,
      medium: 2,
      low: 1
    }
    return scores[severity] || 0
  }

  /**
   * 规范化严重程度
   */
  private normalizeSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
    const normalized = severity.toLowerCase()
    if (normalized === 'critical') return 'critical'
    if (normalized === 'high') return 'high'
    if (normalized === 'moderate' || normalized === 'medium') return 'medium'
    return 'low'
  }

  /**
   * 修复漏洞
   */
  async fix(): Promise<{ success: boolean; message: string; fixed: number }> {
    try {
      const { stdout } = await execa('npm', ['audit', 'fix', '--json'], {
        cwd: this.projectDir,
        reject: false
      })

      try {
        const result = JSON.parse(stdout)
        const fixed = result.metadata?.fixed || 0

        return {
          success: true,
          message: `成功修复 ${fixed} 个漏洞`,
          fixed
        }
      } catch {
        return {
          success: true,
          message: '漏洞修复完成',
          fixed: 0
        }
      }
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : '修复失败',
        fixed: 0
      }
    }
  }

  /**
   * 强制修复（可能导致破坏性更新）
   */
  async fixForce(): Promise<{ success: boolean; message: string; fixed: number }> {
    try {
      const { stdout } = await execa('npm', ['audit', 'fix', '--force', '--json'], {
        cwd: this.projectDir,
        reject: false
      })

      try {
        const result = JSON.parse(stdout)
        const fixed = result.metadata?.fixed || 0

        return {
          success: true,
          message: `强制修复完成，修复了 ${fixed} 个漏洞（可能包含破坏性更新）`,
          fixed
        }
      } catch {
        return {
          success: true,
          message: '强制修复完成',
          fixed: 0
        }
      }
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : '修复失败',
        fixed: 0
      }
    }
  }

  /**
   * 生成漏洞摘要
   */
  getSummary(vulnerabilities: Vulnerability[]): {
    total: number
    bySeverity: Record<string, number>
    bySource: Record<string, number>
    fixable: number
  } {
    const bySeverity: Record<string, number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    }

    const bySource: Record<string, number> = {}
    let fixable = 0

    for (const vuln of vulnerabilities) {
      bySeverity[vuln.severity]++

      if (vuln.source) {
        bySource[vuln.source] = (bySource[vuln.source] || 0) + 1
      }

      if (vuln.fixAvailable) {
        fixable++
      }
    }

    return {
      total: vulnerabilities.length,
      bySeverity,
      bySource,
      fixable
    }
  }
}

